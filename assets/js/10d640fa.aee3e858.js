(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9175],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return u},kt:function(){return _}});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=o.createContext({}),d=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=d(e.components);return o.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},s=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),s=d(t),_=r,m=s["".concat(c,".").concat(_)]||s[_]||p[_]||i;return t?o.createElement(m,a(a({ref:n},u),{},{components:t})):o.createElement(m,a({ref:n},u))}));function _(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=s;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var d=2;d<i;d++)a[d]=t[d];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}s.displayName="MDXCreateElement"},8625:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return a},metadata:function(){return l},toc:function(){return c},default:function(){return u}});var o=t(2122),r=t(9756),i=(t(7294),t(3905)),a={},l={unversionedId:"lab-handouts/lab3_b",id:"lab-handouts/lab3_b",isDocsHomePage:!1,title:"lab3_b",description:"Part-A: Design a 3-to-8 binary decoder by instantiating only 2-to-1 multiplexers.",source:"@site/docs/lab-handouts/lab3_b.mdx",sourceDirName:"lab-handouts",slug:"/lab-handouts/lab3_b",permalink:"/docs/lab-handouts/lab3_b",version:"current",frontMatter:{}},c=[{value:"Part-A: Design a 3-to-8 binary decoder by instantiating only 2-to-1 multiplexers.",id:"part-a-design-a-3-to-8-binary-decoder-by-instantiating-only-2-to-1-multiplexers",children:[{value:"Use below mentioned description of 2x1 Mux to describe Decoder",id:"use-below-mentioned-description-of-2x1-mux-to-describe-decoder",children:[]}]},{value:"Part B: Design fulladder by instantiating only the above designed binary decoder and 8-input or-gate as outlined below.",id:"part-b-design-fulladder-by-instantiating-only-the-above-designed-binary-decoder-and-8-input-or-gate-as-outlined-below",children:[]}],d={toc:c};function u(e){var n=e.components,t=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"part-a-design-a-3-to-8-binary-decoder-by-instantiating-only-2-to-1-multiplexers"},"Part-A: Design a 3-to-8 binary decoder by instantiating only 2-to-1 multiplexers."),(0,i.kt)("h3",{id:"use-below-mentioned-description-of-2x1-mux-to-describe-decoder"},"Use below mentioned description of 2x1 Mux to describe Decoder"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",1:!0,className:"language-vhdl",metastring:'title="2 x 1 MUX"',title:'"2',x:!0,'MUX"':!0},"library ieee;\nuse ieee.std_logic_1164.all ;\n\nentity mux_2_1 is port ( inp1, inp0 : in std_logic ; sel : in std_logic ;\n       outp  : out std_logic ) ;\nend entity ;\n\narchitecture rch_1_mux_2_1 of mux_2_1 is \nbegin\n  outp <= inp1 when sel='1' else inp0 ;\nend rch_1_mux_2_1 ;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-vhdl",metastring:'title="Skeleton Code for 3-to-8 Decoder"',title:'"Skeleton',Code:!0,for:!0,"3-to-8":!0,'Decoder"':!0},"library ieee; use ieee.std_logic_1164.all ;\n\nentity dcdr_3_8 is port ( inp : in std_logic_vector(2 downto 0) ; \n       outp  : out std_logic_vector(0 to 7) ) ;\nend entity ;\n\narchitecture rch_1_dcdr_3_8 of dcdr_3_8 is \n  component mux_2_1 port ( inp1, inp0 : in std_logic ; sel : in std_logic ; outp : out std_logic ) ;\n  end component ;\n--  ..............\n--  ..............\nbegin\n  -- One suggested collection of mux_2_1 instances that would suffice is along the  following lines\n  -- You are permitted to use any other scheme. However only mux_2_1 instances.\n  -- No other concurrent statement with any logic expression is permitted. If at all, statements\n  -- making logic-less connections among each other is permitted.\n  mx_i_0 : mux_2_1 port map ( ............ ) ;\n  mx_i_1 : mux_2_1 port map ( ............ ) ;\n  mx_i_00 : mux_2_1 port map ( ............ ) ;\n  mx_i_01 : mux_2_1 port map ( ............ ) ;\n  mx_i_10 : mux_2_1 port map ( ............ ) ;\n  mx_i_11 : mux_2_1 port map ( ............ ) ;\n  mx_i_000 : mux_2_1 port map ( ......... , outp(0) ) ;\n  mx_i_001 : mux_2_1 port map ( ......... , outp(1) ) ;\n  mx_i_010 : mux_2_1 port map ( ......... , outp(2) ) ;\n  mx_i_011 : mux_2_1 port map ( ............ ) ;\n  mx_i_100 : mux_2_1 port map ( ............ ) ;\n  mx_i_101 : mux_2_1 port map ( ............ ) ;\n  mx_i_110 : mux_2_1 port map ( ............ ) ;\n  mx_i_111 : mux_2_1 port map ( ......... , outp(7) ) ;\nend rch_1_dcdr_3_8 ;\n")),(0,i.kt)("h2",{id:"part-b-design-fulladder-by-instantiating-only-the-above-designed-binary-decoder-and-8-input-or-gate-as-outlined-below"},"Part B: Design fulladder by instantiating only the above designed binary decoder and 8-input or-gate as outlined below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-vhdl"},"----------------\nlibrary ieee; use ieee.std_logic_1164.all ;\n\nentity or_8 is port ( inp : in std_logic_vector(0 to 7) ;\n       outp  : out std_logic ) ;\nend entity ;\n\narchitecture rch_1_or_8 of or_8 is \nbegin\n  outp <= inp(0) or inp(1) or inp(2) or inp(3) or inp(4) or inp(5) or inp(6) or inp(7) ;\nend rch_1_or_8 ;\n\n----------------\n\nlibrary ieee; use ieee.std_logic_1164.all ;\n\nentity fulladder is port ( a,b,cin : in std_logic ; cout, sum : out std_logic ) ;\nend entity ;\narchitecture rch_1_fulladder of fulladder is \n  component dcdr_3_8 is port ( inp : in std_logic_vector(2 downto 0) ; \n       outp  : out std_logic_vector(0 to 7) ) ;\n  end component ;\n  component or_8 port ( inp : in std_logic_vector(0 to 7) ; \n                        outp : out std_logic ) ;\n  end component ;\n .........\n .........\nbegin\n  dcdr_i0 : dcdr_3_8 port map ( ........... ) ;\n  or_i1 : or_8 port map ( ...... , sum  ) ;\n  or_i2 : or_8 port map ( ...... , cout ) ;\nend rch_1_fulladder ;\n----------------\n\n")))}u.isMDXComponent=!0}}]);